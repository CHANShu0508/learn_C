# 字符串

## 13.1 字符串字面量

**字符串字面量**（string literal）就是用一对双引号括起来的字符序列。

我们在`scanf`和`printf`函数中很早就见到过字符串字面量。

### 13.1.1 字符串字面量中的转义序列

我们在`printf`等函数中用到的诸如`\n`等就是转义序列。

> * 注意：在使用**八进制和十六进制时的ASCII转义序列**时需要注意的是：八进制转义序列的位数最多是3位，也就是说，这个转义序列结束的条件是：
>   * 达到3位以上，如`\3456`其实编译器理解为`\345`  `6` 
>   * 遇到不会再8进制内出现的数字，如9
>
>   十六进制也是相似的

### 13.1.2 延续转义序列

当转义序列太长影响美观度时，我们可以将转义序列转移到下一行，主要有两种方法：

1. 使用 `\`，反斜杠

   ```c
   printf("I just want to write a long line of words	\
   I just want to write a long line of words");
   ```

   但是，这么做需要下一行从起始位置开始，也影响美观度，所以有第二种方法：

2. 使用两个`""`

   ```c
   printf("I just want to write a long line of words"
         "I just want to write a long line of words")
   ```

   这样就好看多了。

### 13.1.3 如何储存字符字面量

C语言的编译器常常把字符字面量也就是字符串当作一个字符数组，但是它和字符数组有很大的区别，这个区别就是：在字符字面量的最后一位，是以`\0`填充的，注意就是`\0`，不是`'0'`。这个东西就是空字符，不是空格也不是0，就是一个空的东西。

> 例如：字符字面量“234”在内存中的形式就是：
>
> |  '2'  |  '3'  |  '4'  |  '\0'  |
>
> 结尾的是**'\0'**而不是**'0'**！

然后就是既然字符串字面量是以数组的形式储存的，那么编译器就可以将它视为`char *`类型的指针，事实上像`printf`和`scanf`这些函数接受的就是指针的形式。

### 13.1.4 字符串字面量的操作

由于C语言中指针的特性和字符串的储存特性，我们可以使用字符串在任何可以使用指针`char *`的地方比如：

* 在初始化一个字符串的时候：

  ```c
  char *p;
  p = "abc";
  ```

  虽然我们知道数组有不可复制的特性，但是此处并不是在复制这个字符串的内容。这个代码其实完成了三个工作：创建了一个`char`类型的指针`*p`；创建了内容为`abc\0`的字符串；最后将指针`p`指向了这个字符串的第一个字符。

  **注意：使用数组声明字符串时不可以这样操作，因为这么做实质是把这个未初始化的指针指向一个字符串字面量，而一个数组的名字不可以做左值当指针被赋值，也就是说过的，不能给一个数组名指针赋值！！**

  > ```c
  > char str[4];
  > str = "abc";    /*** WRONG ***/
  > ```

* 可以对指针取下标意味着我们可以对字符串取下标：

  ```c
  char ch;
  ch = "abc"[1];
  ```

  就意味着字符变量`ch`的值就是`'a'`这个字符。虽然不常用，但是我们可以使用如下的程序来将十进制（或者其他）变为十六进制后输出：

  > ```c
  > char digit_to_hex_char(int digit)
  > {
  >    	return "0123456789ABCDEF"[digit]
  > }
  > ```
  >

需要注意的是：**字符串字面量的内容是不可修改的，所以当我们使用的是指针类型初始化的字符串，我们将不能修改这个指针类型初始化的字符串中的内容**。原因在后面我们会提到。

## 13.2 字符串变量

在很多编程语言中对于字符串专门定义了string类型，但是C语言没有，在C语言中，只要在字符变量数组最后一位一空字符结尾就是字符串。这么做虽然便捷，但是非常的危险（相较于有专门的string类型的语言），因为我们**很难辨别一个字符变量数组到底只是一个数组还是一个字符串**。

所以为了减小危险程度，我们在定义一个字符串的时候一定要注意它的长度！比需要的长一位来存放空字符，用下边的惯用法是比较安全的：

```c
[惯用法]
#define STR_LEN 80
...
char str[STR_LEN + 1];
```

始终记得加一就可以。

### 13.2.1 初始化字符串变量

主要有三种方法：

1. 直接声明数组法：

   ```c
   char str[9] = {'A', 'u', 'g', 'u', 's', 't', ' ', '1', '\0'};
   ```

   但是一看就知道这个东西很麻烦。（但是可以注意长度确实比字符数量长一个）

2. 字符串直接声明法：

   ```c
   char str[9] = "August 1";
   ```

   就可以了，可以把字符串字面量的内容直接复制给数组。

   但是需要注意的还是长度，当你把长度不小心写长了一位时：

   ```c
   char str[10] = "August 1";
   ```

   在内存中将会是`| A | u | g | u | s | t |   | 1 | \0 | \0 |`

   也就是会在没有声明到的地方自动补充空字符，和数组声明中自动补0的做法非常像。

   而当你把长度不小心写短了就惨了，因为这个数组的范围中将没有空字符的出现，这是非常危险的。

   所以可以空出长度的位置，让编译器去数这个字符串的长度。

   ```c
   char str[] = "August 1";
   ```

上面提到的两种都是使用数组初始化声明的用法。下个小节将是使用指针声明的用法。

### 13.2.2 字符数组与指针

```c
char str[] = "August 1";
char *str = "August 1";
```

我们可以使用下面的方式去初始化一个字符串，但是这两种方式不是完全相同的，也就是数组和指针毕竟还不是完全相同的。

* 当使用指针去初始化一个字符串时，你将不能通过指针或者其他方式修改这个字符串，因为在你初始化的时候，编译器认为你把一个指针指向了一个字符串字面量，而字符串字面量是不可以修改的，所以你的字符串也就是不可修改的。
* 而当你用数组去初始化是，这个字符串是可以修改的。

## 13.3 字符串的读和写

### 13.3.1 写字符串

输出字符串不是一个难事，使用`printf`或者`put`都可以输出字符串的内容。

使用`printf`时，转化说明为**`%s`**：

```c
char str[] = "Hello world!";
printf("%S\n", str);
```

在使用`printf`时需要注意：

* `printf`一个个输出字符串中的内容，直到遇见`\0`才停止，这个时候就显示到缺失空字符对于字符串的危险性，如果缺失，`printf`将会永无止尽沿着内存的读下去，直到遇见空字符。
* 可以使用`%m.ps`来对输出进行调整，和其他转化说明一样：
  * `m`指最小的输出长度，短于这个长度，输出将会自动向右对齐（添加一个负号会左对齐）；长于这个长度会继续输出。
  * `.p`指要显示的字符长度，也就是最大长度，长于这个长度就会截断后面的输出。

然后就是使用`put`函数，使用这个函数只有一个参数，就是要输出的字符串的名字，输出之后，将会自动换行：

```c
char str[] = "Hello world!";
put(str);
```

### 13.3.2 读字符串

使用`scanf`或者`get`函数都可以写入，但是两个函数有些不同。

使用`scanf`时，转化说明依然是`%s`：

```c
char str[STR_LEN + 1];
scanf("%s", str);
```

可以注意到，我们在写入的时候，在字符串前面不需要添加`&`，因为字符串的名字本身就是指针。而`scanf`函数将会：

* 自动跳过没有遇到非空白字符之前输入中的空白字符（空格，回车等）
* 遇到空白字符（不是空字符`\0`）时停止，并自动给字符串末尾写上空字符

所以，这就是`scanf`的特性：它永远不会读入空白字符，也就意味着，如果用`scanf`来读取内容，不可以读取你写入的一整行内容。

> 所以，如果你写入的是
>
> ```txt
> Hello world.
> ```
>
> `scanf`将会只读取到
>
> ```txt
> Hello
> ```

为了一次读入一整行的内容，我们可以使用`get`函数，它的特点是：

* 不会在正式读取之前跳过空白字符
* 持续读入，直到换行符的位置

所以，`put`函数是真的把你输入的一整行的内容全部读入了。

---

需要注意的是：**`scanf`和`get`函数都没有办法检测你的输入是否超出了字符串的范围**，而使用转化说明`%ns`来限制最多读入的字符数来保证安全。

### 13.3.3 逐个读取字符

为了结合两个读取函数的优点并且保证读取安全，我们可以自己设计一个读取的函数，特性如下：

* 不跳过空白字符；
* 遇到换行符终止；
* 设置最大读取数，达到后自动终止并抛弃其他的.

所以函数原型如下：

```c
int read_line(char str[], int n);
```

`str[]`是要存入数据的字符串，而`n`是最大的长度。这个函数将会返回储存在字符串中实际字符的数量：

```c
int read_line(char str[], int n)
{
    int ch, i = 0;
    
    while ((ch = getchar()) != '\n') {
        if (i < n) {
            str[i++] = ch;
        }
    }
    str[i] = '\0';		// terminates string
    return i;		    // number of chars stored
}
```

### 13.4 访问字符串中的字符

基本上就是两个准则：

* 声明的时候，如果想要在后面可以修改，就不要使用指针声明
* 访问的时候，使用指针会是高效率



## 13.5 使用字符串库函数

我们知道，数组是不可复制的，由于这个特性，字符串也是不可复制的。并且不可拼接，不可比较等。当我们想使用这些功能而不必要自己写一个函数出来时，我们可以使用字符串的库函数，记得在最开始带上`<string.h>`的头文件。

注意：在使用这些库函数进行修改的时候，你的字符串不要是指针指向字符串字面量的形式。

### 13.5.1 strcopy 函数

这个是用来复制字符串的函数：

```c
char *strcopy(char *s1, const char *s2);
```

在库函数中的原型如上。作用是将进来的`s2`字符串复制给`s1`字符串（所以`s2`上有`const`）。

复制的时候是复制`s2`内容，直到遇见`\0`，顺便将`\0`也带过去给`s1`补上。这个函数的返回值是`s1`这个字符串的指针。

```
strcopy(str1, strcopy(str2, str3));
```

就是这么操作，内容就是先把`str3`复制给`str2`，然后再把`str2`复制给`str1`

但是`strcopy`无法保证，`s2`的长度在`s1`的长度范围之内，使用`strncpy`会是更安全的选择：

```c
strncpy(str1, str2, sizeof(str1));
```

操作将会如上，第三个参数将会保证被写入`str1`的最多的字符数，但是还是有一些它无法顾及的地方：由于**两个复制的函数都无法自动填充`\0`**，所以最好用下变的用法：

```c
strncpy(str1, str2, sizeof(str1) - 1);
str1[sizeof(str1) - 1] = '\0';
```

将结尾填充上空字符。

### 13.5.2 strlen 函数

这是用来求字符串长度的函数，原型如下：

```c
size_t strlen(const char *s);
```

不用管`size_t`是什么，就把它当作`int`就可以，这个函数的返回值是这个字符串的`\0`之前的长度（不包括`\0`）

### 13.5.3 strcat 函数

用来拼接字符串的函数，原型是：

```c
char *strcat(char *s1, const char *s2);
```

它把`s2`的内容拼接到`s1`末尾并且返回指向`s1`的指针。

这个函数的用法与问题和`strcopy`是一样的，所以为了安全，我们使用`strncat`函数：

```c
strncat(str1, str2, sizeof(str1) -strlen(str1) - 1);
str1[sizeof(str1) - 1];
```

这样的惯用法将会保证使用拼接函数的安全。

### 13.5.4 strcmp 函数

它是用来比较字符串的函数。原型如下：

```c
int strcmp(const char *s1, const char *s2);
```

这个函数将比较输入的两个函数，然后根据`s1`是小于、等于或者大于`s2`返回一个小于、等于或者大于0的整数。

判断的依据，什么时候`s1`会小于`s2`：

* 当`s1`与`s2`的前`i`个字符是一致的，但是`si`的第`i+1`个字符小于`s2`的第`i+1`个字符；
* `s1`的所有字符和`s2`一致，但是`s1`要比`s2`短；
* 字符的大小指的是ASCII值的大小，数字<大写字母<小写字母，空格小于所有打印字符。



## 13.6 字符串惯用法

### 13.6.1 搜索字符串的结尾

我们可以用自己编写的`strlen`函数来表示这个惯用法（但是要注意写的时候函数名不要与库函数冲突，当然你也没必要写）

```c
size_t strlen(const char *s)
{
    size_t n;
    for (n = 0; *s != '\0'; s++) {
        n++;
    }
    return n;
}
```

这个版本可能有些复杂。我们可以观察到：

* n 的等于0的定义可以融合在声明中
* `*s != '\0'`和`*s != 0`是一样的
* s的自增可以融合在一起

简化的版本可以是：

```c
size_t strlen(const char *s)
{
    size_t n = 0;
    while (*s++) {
        n++;
    }
    return n;
}
```

尽管这样已经非常简化了，对编译器来说则是一点区别都没有，下面的版本可以真正提高速度：

```c
size_t strlen(const char *s)
{
    const char *p = s;
    while (*s) {
        s++;
    }
    return s - p;
}
```

需要注意的是：`p`的声明时必须要加`const`，如果没有，**编译器将会注意到`s`指向的字符将会有被修改的危险**。

所以搜索时遍历的惯用法是：

```c
[惯用法1]
while (*s)
    s++;
```

```c
[惯用法2]
while(*s++)
    ;
```

### 13.6.2 复制字符串

这个我们以拼接字符串的`strcat`为例，下面是复杂的版本：

```c
char *strcat(char *s1, const char *s2)
{
	char *p = s1;
    while (*p != '\0') {
        p++;
    }
    while (*s2 != '\0') {
		*p = *s2;
        p++;
        s2++;
    }
    *p = '\0';
    return s1;
}
```

这个函数首先搜索到`s1`的空字符，然后将`s2`的值赋给`s1`后面的序列，最后补上空字符。

简化后的是：

```c
char *strcat(char *s1, const char *s2)
{
    char *p = s1;
    while (*p)
        p++;	
    while (*p++ = *s2++)
        ;	/* empty loop body */
    return s1;
}
```

后面的一个循环就是增加的同时赋值。`while`会检测赋值的值作为条件表达式的值，如果赋值到`\0`就会终止。

### [13.6.3 示例程序：显示一个月的提醒列表](../example_codes/chapter13/reminder.c)

这个程序会显示一个月的每日提醒列表。用户需要输入一系列提醒，每条提醒之前都要有一个前缀说明是一个月中的哪一天，当输入的是0时，程序会显示录入的全部提醒的列表，按日期排序的。与程序的会话如下：

```
Enter day and reminder: 13 Go to a movie
Enter day and reminder: 12 Take a walk
Enter day and reminder: 3 Have a break
Enter day and reminder: 5 Do sports
Enter day and reminder: 0

Day Reminder
 3 Have a break
 5 Do sports
12 Take a walk
13 Go to a movie
```

要点如下：

* 我们用到了`sprintf`函数：`sprinf(day_str, %2d, day)`，这样的用法。原理是后面的参数就像`printf`一样输出，但是输出结果以字符串的形式被写入了`day_str`中，我们用来解决使日期排版右对齐的问题。
* 储存的方法就是使用了一个字符串数组，注意其中字符串数组的使用方法，虽然它是一个二维的数组，但是用的时候确实当作一维数组，每行被当作一个字符串元素。
* 排序的策略就是一边输入一边排序，输入一个检测一个，小的就让大的往后移动，可以看程序中的详细步骤，非常的妙。



## 13.7 字符串数组

在前面我们提到过字符串的数组和指针的定义方法，下面我们将会讨论一个问题：储存字符串数组的最佳方式是什么？

在之前的示例代码之中，我们是用数组的方式定义了一个字符串数组，我们以行星为例，看看数组定义的字符串数组在内存中是什么样的：

```c
char planets[][8] = {"Mercury", "Venus", "Earth",
                    "Mars", "Jupiter", "Saturn",
                    "Uranus", "Neptune", "Pluto"};
```

```
| M | e | r | c | u | r | y |\0 |
| V | e | n | u | s |\0 |\0 |\0 |
| E | a | r | t | h |\0 |\0 |\0 |
| M | a | r | s |\0 |\0 |\0 |\0 |
| J | u | p | i | t | e | r |\0 |
| S | a | t | u | r | n |\0 |\0 |
| U | r | a | n | u | s |\0 |\0 |
| N | e | p | t | u | n | e |\0 |
| P | l | u | t | o |\0 |\0 |\0 |
```

是这样储存的，可以看到由于一个字符串必须占据定义的数组的列数，于是有很多空间是浪费的，全储存了`\0`。所以我们得出结论：**我们想要的是参差不齐的数组**，使用指针定义字符串数组可以做到这一点。

```c
char *planets[] = {"Mercury", "Venus", "Earth",
                    "Mars", "Jupiter", "Saturn",
                    "Uranus", "Neptune", "Pluto"};
```

以这样的形式定义在内存中则会是：

```
| M | e | r | c | u | r | y |\0 |
| V | e | n | u | s |\0 |
| E | a | r | t | h |\0 |
| M | a | r | s |\0 |
| J | u | p | i | t | e | r |\0 |
| S | a | t | u | r | n |\0 |
| U | r | a | n | u | s |\0 |
| N | e | p | t | u | n | e |\0 |
| P | l | u | t | o |\0 |
```

因为这个“指针数组”记录的是每个字符串字面量的地址，不会有很多浪费。

## 13.8 访问命令行参数

C程序其实可以访问命令行中的参数，以字符串的形式，比如指令：

```cmd
ls -l remind.c
```

它的作用是显示文件的详细信息（我们不关心这个）。如果C语言想要访问这些内容，就需要在`main`函数的参数内包括两个参数：

```c
int main(int argc, char *argv[])
{
    ... ...
}
```

`argc`这个整数性的变量是命令行中参数的数量，那么我们在上面列出的命令行就有三个参数：`ls`, `-l`和`remind.c`；而且这三个参数都是以字符串的形式储存在指针数组`argv[]`之中（从`argv[0]`到`argv[argc - 1]`），而且C语言保留了`argv[argc]`作为一个**空指针**。所以，命令行中的指令在内存中是：

```
| 0 | --> 程序名 | l | s |
| 1 | --> | - | l |
| 2 | --> | r | e | m | i | n | d | e | r | . | c |
| 3 | --> NULL(空指针)
```

### [13.8.1 示例程序：核对行星的名字](../example_codes/chapter13/planet.c)

此程序的目的是为了检查一系列字符串，从而找出那些字符串是行星的名字。程序执行时，用户将把待测的字符串放置在命令行中。

只有首字母大写且拼写正确的才能识别为行星的名字。如果是，程序还将显示行星的编号。

---

## 13.9 注意&提醒

* 无论在实际的参数中，使用指针或者字符串声明一个字符串有什么样的不同，在形式参数的声明时，使用`*a`和`a[]`总是一样的。