# 读入函数的返回值 & EOF

## 读入函数的返回值是什么？

除了知道`getchar` 本身是有返回值的，其实很常用的`scanf`也是有返回值的。

### `getchar()` 函数

我们经常使用`getchar` 来一个一个字符的读取输入。虽然经常直接使用一个`char`类型的字符变量来接受它的值，但是其实`getchar`的返回值是`int` 类型的数值，经过编译器的类型转化赋值给字符变量的。

### `scanf()`函数

大多数时间我们不会去使用`scanf`的返回值，但是它的确有一个`int`类型的返回值，它的值就是函数读取成功的变量数。注意，在如下情况`scanf`会读取失败：

* 在转化说明与输入类型不符时；
* 在输入值缺失时；
* 人为中断时.

> 如：
>
> ```c
> scanf("%d%d%d", &a, &b, &c);
> ```
>
> 若输入：`1 2 3` 则返回值为**3**
>
> ​				`1 2 d` 则返回值为**2**
>
> ​				`Ctrl+D`则返回EOF

## EOF 相关

到底什么是`EOF`？

简单讲就是在这些输入类型的函数在读取到缓冲区的结尾时，函数将告诉你：这里没有东西了，于是返回`EOF`。

但实际上`EOF`是定义在`stdio.h` 头文件中的一个宏 `#define EOF -1` 也就是说它的值是 -1（为何是-1是个耐人深思的问题）

---

**对于`getchar`就很好说**，因为他只读取一个字符，没了就是没了。

**但是对于`scanf`**，由于它可以读取多个数值，究竟是何种情况下返回`EOF` 呢？

经实验发现不管有几个待输入的变量，只有在缓冲区什么都没有的时候（包括只有一个空白字符时）的返回值才是`EOF`。一旦有输入，就符合`scanf`的返回值规则（在多个待输入，缓冲区只有一个错误类型时返回1，完全缺失时则返回`EOF`）

我们对以下代码实验：

```c
#include<stdio.h>
int main()
{
	int a, b, c;
	printf("%d", scanf("%d%d%d", &a, &b, &c));
	return 0;
}
```

当输入为`1 ` 时，返回为1；

当输入为`d` 时，返回为0；

当输入为 `  `时，返回为`EOF`.